## `Dockerfile`基础

`Dockerfile`仅仅是一个用来构建`docker`镜像的源码，一旦有了此文件，`Docker`就可以去读取对应的指令来自动构建镜像，`Dockerfile`是一个纯文本文件，只不过这个纯文本文件中的内容被称作`Dockerfile`的指令，这个指令是有特定格式的，所谓特定指令是指`Dockerfile`所支持识别的指令，`Dockerfile`文件制作完毕后，就可以构建`docker`镜像。

构建`docker`镜像时，必须要有一个工作目录，工作目录内只存放`dockerfile`以及被`dockerfile`所依赖的文件，或者需要被复制到镜像内的文件，并且需要被复制到镜像内的文件只能起始于此目录中，否则将无法复制进镜像内。不要放任何与当前镜像构建无关的文件。使用`docker build`构建镜像时，只需要指定`Dockerfile`文件所在的目录即可，并且`Dockerfile`文件的命名只能是`Dockerfile`

### `Dockerfile`文件格式

#### 指令

`Dockerfile`文件是由2类指令构成：

1. `# Comment`: 注释信息
2. `INSTRUCTION arguments`: 指令参数信息

指令本身不区分字符大小写，但是一般写为纯大写。

一般来说第一条指令为`FROM`，用来指定基础镜像

**注意**：`Dockerfile`每一条命令生成一层镜像。层级越多读写性能越差，因为首次访问为`COW`机制，但是在镜像拉取和分发时实现并行提高速度，而且精细的镜像层可以被其他镜像所共享。层级太少可能导致其底层无法被其他镜像共享使用，每次拉取镜像时将是一个很大的文件。所以应该将关系比较精密的操作放在一层中进行构建。

#### `entrypoint`脚本

传统的程序运行时需要使用到配置文件，以`nginx`为例，更具其使用的方式不同其对应的配置也不同，而每个环境（`dev`, `test`, `pre`, `prod`）所设置的配置参数更是不一样，这将将会产生十几到二十几套配置文件。而到了容器时代，再使用配置文件来进行对程序的参数进行调整后打入镜像这将会产生众多的镜像层，并且易于管理。

所以`Dockerfile`采用了传环境变量+`entrypoint`脚本的方式来应对多种不同的环境，在`entrypoint`脚本中配置好各种不同环境所需要的参数，更具传入的变量不同，配置不同的参数，在`entrypoint`脚本的最后将容器中所需要运行的程序运行起来。

#### `Environment replacement`

环境变量与`shell`中所说的没有本质上的区别，变量定义完毕后就可以进行引用，引用方式`$variable_name`或`${variable_name}`。

定义变量：`ENV`指令	

```bash
ENV <key>=<value> ...
```

变量引用时支持`bash`中的两种引用方式：

* `${variable:-word}`: 当`var`为空或未设定时，则使用`word`为此变量的默认值。
* `${variable:+word}`: 变量有值时使用`word`为此变量的返回值，为空或未设定时返回空。

#### `Dockerignore File`

`Docker`的工作目录可以用来存放众多与`Dockerfile`文件相关连的文件，但是某些时候可能在其工作目录内产生一些不需要被打入进行的文件或者某些临时文件。这时候可以在工作目录下写一个`.dockerignore`的文件，文件内一行写入一个不需要被打入镜像的文件名（可以使用通配符）。

